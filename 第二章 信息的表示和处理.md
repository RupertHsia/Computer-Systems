# 第二章　信息的表示和处理

研究三种最重要的数字表示。**无符号（unsigned）编码**基于传统的二进制表示法，表示大于或者等于零的数字。**补码（two's-complement）编码**是表示有符号整数的最常见方式。**浮点数（floatting-point）编码**是表示实数的科学计数法的以2为基数的版本。

计算机的表示法是用有限的位来对一个数字编码，因此，当结果太大以至于不能表示时，某些运算就会出现**溢出（overflow）**。

对于浮点数而言，由于表示的精度有限，所以浮点运算是不可结合的。

大量的计算机的安全漏洞都是由于计算机算术运算的微妙细节引发的。

## 2.1 信息存储

大多数计算机使用字节（byte）作为最小的可寻址内存单元，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，成为**虚拟内存（virtual memory）**。内存的每一个字节都有一个唯一的数字标识，成为它的**地址（address）**，所有可能的地址的集合成为**虚拟地址空间（virtual address space）**，这个虚拟地址空间只是一个展现给机器级程序的概念性映像，实际实现是将DRAM、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

### 2.1.1 十六进制表示法

### 2.1.2 字数据大小

每台计算机都有一个**字长（word size）**，指明指针数据的**标称大小（nominal size）**。因为虚拟地址是以这样的一个字来编码的，所以字长最终决定的最重要的系统参数就是虚拟空间的最大大小。

32位字长限制虚拟地址空间为4GB，扩展到64位字长使得虚拟地址空间为16EB。大多数64位机器也可以运行位32位机器编译的程序，这是一种向后兼容。当程序*prog.c*用如下伪指令编译后

> linux> *gcc -m32 proj.c*

该程序可以在32位或者64位机器上正确运行，另一方面，若使用下述伪指令编译

> linux>*gcc -m64 prog.c*

那就只能在64位机器上运行。
